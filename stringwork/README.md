1.
Дана входная строка s, переверните порядок слов.

Слово определяется как последовательность символов, не являющихся пробелами. 
Слова в строке s разделены как минимум одним пробелом.

Верните строку, в которой слова расположены в обратном порядке, 
соединённые одним пробелом.

Обратите внимание, что строка s может содержать пробелы в начале или в конце, или множественные пробелы между двумя словами. 
Возвращаемая строка должна содержать только один пробел, разделяющий слова. Не включайте лишние пробелы.

Разобьем строку strings.Fields(s) - в массив
разделим пополам массив и пройдемся меняя местами 
элементы массива.

[//]: # (`Удаление лишних пробелов:)

[//]: # (Удалите начальные и конечные пробелы из строки s. Это делается для того, чтобы убрать пробелы в начале и в конце строки, которые могут исказить конечный результат. )

[//]: # (В коде это реализовано с помощью методов erase и find_first_not_of/find_last_not_of, которые удаляют пробелы до первого и после последнего непробельного символа.)

[//]: # ()
[//]: # (Разделение строки на слова:)

[//]: # (Преобразуйте строку s в поток и используйте istringstream для чтения слов, разделенных пробелами. )

[//]: # (Каждое слово определяется как последовательность символов, не содержащая пробелов. )

[//]: # (Слова сохраняются в вектор words. Это делается с помощью copy, который копирует слова из потока в words с помощью istream_iterator.)

[//]: # ()
[//]: # (Реверсирование и соединение слов:)

[//]: # ()
[//]: # (Переверните вектор слов и соедините их обратно в одну строку, разделяя слова одним пробелом. )

[//]: # (Для реверсирования используется функция reverse, а для соединения слов — ostringstream вместе с ostream_iterator.)

[//]: # (Слова объединяются таким образом, что между ними находится только один пробел, исключая лишние пробелы между словами.`)

2.
Дана строка s и словарь строк wordDict. Добавьте пробелы в строку s, чтобы построить предложение, в котором каждое слово является допустимым словом из словаря. 
Верните все такие возможные предложения в любом порядке.

Обратите внимание, что одно и то же слово из словаря может использоваться несколько раз при разделении.

Алгоритм

Инициализация и начальный вызов:
Преобразуйте массив wordDict в множество wordSet для эффективного поиска.
Инициализируйте пустой массив results для хранения допустимых предложений.
Инициализируйте пустую строку currentSentence для отслеживания конструируемого предложения.
Вызовите функцию backtrack с исходной строкой s, множеством wordSet, текущим предложением currentSentence, 
массивом результатов results и начальным индексом, установленным в 0 — начало входной строки.
Верните results после завершения работы backtrack.

Функция backtrack:
Базовый случай: Если startIndex равен длине строки, добавьте currentSentence в results и вернитесь, 
так как это означает, что currentSentence представляет собой допустимое предложение.
Итерация по возможным значениям endIndex от startIndex + 1 до конца строки.

Обработка и рекурсия:
Извлеките подстроку word от startIndex до endIndex - 1.
Если word найдено в wordSet:
Сохраните текущее значение currentSentence в originalSentence.
Добавьте word к currentSentence (с пробелом, если это необходимо).
Рекурсивно вызовите backtrack с обновленным currentSentence и endIndex.
Сбросьте currentSentence к его исходному значению (originalSentence) для отката и попробуйте следующий endIndex.
Вернитесь из функции backtrack.

3.
Получаем из строки все вхождения строка, присутствующих в словаре
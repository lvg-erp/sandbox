https://kovardin.ru/articles/go/modeli-konkurentnosti-v-go/


Паттерн fan-out/fan-in используется для распараллеливания и координации задач (горутин). 
Особенно полезен, когда одну трудоемкую задача можно разделить на более мелкие подзадачи.

Cостоит из двух стадий:

1. Fan-out: задача делится на несколько мелких подзадач, которые затем выполняются конкурентно. 
Каждую подзадачу можно назначить отдельной горутине для параллельного выполнения.

2. Fan-in: результаты всех одновременно выполняемых подзадач собираются и объединяются в единый результат.

Реализация на Go
Используем комбинацию горутин и каналов в Go. Каждая подзадача назначается горутине, а каналы передают данные между горутинами. 
Стадия fan-in ожидает завершения всех подзадач, координируя их с помощью примитивов синхронизации, таких как sync.WaitGroup, 
или используя канал с сигналом о завершении каждой подзадачи.

Пример 1

"Тяжелую" задачу по вычислению факториала разбиваем на несколько подзадач. Для этого:

1. Создаем канал results в него будем записывать результаты вычислений.

2. Для каждого числа из списка nums запускаем горутину, которая вычисляет факториал и отправляет результат в канал out. Это "fan-out".

3. Запускаем горутину, которая ждёт завершения всех "вычислительных" горутин, используя sync.WaitGroup и затем закрывает канал out.

4. В главной горутине читаем результаты из канала out и выводим их.

Возведение в куб

Рассмотри трехэтапный конвейер.

Превый этап. gen это функция, которая преобразует список целых чисел в канал, который посылает числа из этого списка. 
Внутри этой функции запускается go-рутина, которая отправляет целые числа в канал и закрывает этот канал, когда все числа отправлены:

Второй этап. sq забирает числа из канала и возвращает новый канал, который отдает квадрат каждого полученного числа. 
После того как входящий канал закрыт и все значения на этом шаге отправлены в исходящий канал, то исходящий канал закрывается:

Функция main оперирует каналами и реализует последний этап. 
Принимает значения, полученные на втором этапе, и выводит каждое, пока канал не закроется:

ункция sq принимает и возвращает каналы одинакового типа. 
А это значит, что мы можем компоновать эти функции сколько угодно. 
Кроме того, мы можем переписать функцию main с использованием range:
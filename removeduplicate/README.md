ONE

Дан массив целых чисел nums, отсортированный в неубывающем порядке. 
Удалите из него некоторые дубликаты на месте так, чтобы каждый уникальный элемент встречался не более двух раз. 
Относительный порядок элементов должен быть сохранён.

Поскольку в некоторых языках программирования невозможно изменить длину массива, результат следует разместить в первой части массива nums. 
Более формально, если после удаления дубликатов остаётся k элементов, то первые k элементов массива nums должны содержать итоговый результат. 
Не важно, что остаётся за пределами первых k элементов.
лишние элементы помещены в конец массива
Верните k после размещения итогового результата в первые k слотов массива nums.

Не выделяйте дополнительное пространство для другого массива. 
Вы должны сделать это, изменяя исходный массив на месте с использованием дополнительной памяти O(1).

TWO
Дана голова отсортированного связного списка. 
Удалите все узлы, содержащие повторяющиеся числа, оставив только уникальные числа из исходного списка. 
Верните отсортированный связный список.

1️⃣Инициализация "стража" и предшественника:
Создается фиктивный начальный узел sentinel, который указывает на начало связного списка. 
Это делается для удобства управления указателем на начало списка, особенно если первые несколько узлов могут быть удалены.
Устанавливаем предшественника pred, который будет последним узлом перед потенциально дублирующимися узлами. 
Изначально предшественником назначается страж.

2️⃣Проход по списку с проверкой на дубликаты:
Итерируемся по списку начиная с головы head. На каждом шаге проверяем, есть ли дублирующиеся узлы, сравнивая текущий узел head.val с следующим head.next.val.
Если узлы дублируются, то пропускаем все последующие дубликаты, перемещая указатель head до последнего дублированного узла. 
После этого предшественник pred соединяется с первым узлом после всех дубликатов pred.next = head.next, тем самым пропуская весь блок дублированных узлов.

3️⃣Переход к следующему узлу и возврат результата:
Если текущий узел не имел дубликатов, просто переводим предшественника pred на следующий узел.
Двигаем указатель head на следующий узел в списке.
После завершения цикла возвращаем список, начиная с узла, на который указывает sentinel.next, что позволяет исключить 
все дублирующиеся узлы и вернуть начало нового списка без дубликатов.
